using System;
using System.Text;

namespace SteganographyApp.PasswordGenerator
{
    public static class KeyGeneratedPassword
    {
        /// <summary>
        /// This algorthim allows the key to be generated by the user for ease of use
        /// So bascially they key will act as cordinates to the address of the password
        /// it is more vulnerable but is much more liekly to be used
        /// </summary>
        /// <param name="key">this is the user generated key</param>
        /// <param name="metadata"> this is the 'hashed metadata' or whatever is being sent as the data</param>
        /// <param name="passwordLength">this is the length of the password the user chooses</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public static string GeneratePassword(string key, string metadata, int passwordLength)
        {
            if (string.IsNullOrEmpty(key))
                throw new ArgumentException("Key cannot be empty", nameof(key));
            if (string.IsNullOrEmpty(metadata))
                throw new ArgumentException("Metadata hash cannot be empty", nameof(metadata));
            if (passwordLength <= 0)
                throw new ArgumentException("Length must be > 0", nameof(passwordLength));

            // this basically reserves capacity for password
            var password = new StringBuilder(passwordLength);

            string data = Parser.GetReadableData(metadata);



            while (password.Length < passwordLength)
            {
                foreach (char c in key)
                {
                    if (password.Length >= passwordLength)
                        break;

                    // convert char to the oridanal value
                    int ordinal = (int)c;
                    // this is the wrap to keep it inbounds by modding the hashmetadata which effectively keeps it in bounds
                    //example 123456 if index is 8, ends at 2
                    int idx = Math.Abs(ordinal) % metadata.Length;
                    
                    //apped the char from the metadata into password and continue until the password is filled 
                    password.Append(metadata[idx]);
                }
            }
            //return PasswordValidator.CreateValidPassword(password.ToString(), passwordLength);
            return password.ToString();

        }
    }
}
