using System;
using System.Text;

namespace SteganographyApp.PasswordGenerator
{
    public class KeyGeneratedPassword
    {
        /// <summary>
        /// This algorthim allows the key to be generated by the user for ease of use
        /// So bascially they key will act as cordinates to the address of the password
        /// it is more vulnerable but is much more liekly to be used
        /// </summary>
        /// <param name="key">this is the user generated key</param>
        /// <param name="hashedMetadata"> this is the 'hashed metadata' or whatever is being sent as the data</param>
        /// <param name="passwordLength">this is the length of the password the user chooses</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public string GeneratePassword(string key, string hashedMetadata, int passwordLength)
        {
            if (string.IsNullOrEmpty(key))
                throw new ArgumentException("Key cannot be empty", nameof(key));
            if (string.IsNullOrEmpty(hashedMetadata))
                throw new ArgumentException("Metadata hash cannot be empty", nameof(hashedMetadata));
            if (passwordLength <= 0)
                throw new ArgumentException("Length must be > 0", nameof(passwordLength));

            // this basically reserves capacity for password
            var password = new StringBuilder(passwordLength);

            while (password.Length < passwordLength)
            {
                foreach (char c in key)
                {
                    if (password.Length >= passwordLength)
                        break;

                    // convert char to the oridanal value
                    int ordinal = (int)c;
                    // this is the wrap to keep it inbounds by modding the hashmetadata which effectively keeps it in bounds
                    //example 123456 if index is 8, ends at 2
                    int idx = Math.Abs(ordinal) % hashedMetadata.Length;
                    
                    //apped the char from the metadata into password and continue until the password is filled 
                    password.Append(hashedMetadata[idx]);
                }
            }
            return password.ToString();
        }
    }
}
